<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Basic | Blog | danielvaldivv </title>
    <link rel="stylesheet" href="../css/global.css">
    <link rel="stylesheet" href="../css/header.css">
    <link rel="stylesheet" href="../css/footer.css">
    <link rel="stylesheet" href="/danielvaldivv/css/styles-blogs.css">
</head>
<body>  
    <header>
        <section class="home"><a href="../dvBlog.html"><h4>danielvaldivv</h4></a></section>
        
        <nav>
            <a href="../dvBlog.html"><h4>dvBlog</h4></a>
            <a href=""><h4>About me</h4></a>
        </nav>
    </header>
    <picture>
        <div class="picture-blog-two">
        </div>
    </picture>
    <main class="main-blogs">
        <section class="main-blog-section">
            <section class="blog-section-others">
                <ul>
                    <h3>Aquí tienes los últimos 10 blogs</h3>
                    <li><a href="./javascriptBasicBg1.html">JavaScript Basic</a></li>
                    <li><a href="/blogs/javascriptScopeClosure&ScopeBg3.html">Scope, Closures & Hoisting JavaScript</a></li>
                    <li><a href="">Titulo del Blog numero 4, enlace directo</a></li>
                    <li><a href="">Titulo del Blog numero 5, enlace directo</a></li>
                    <li><a href="">Titulo del Blog numero 6, enlace directo</a></li>
                    <li><a href="">Titulo del Blog numero 7, enlace directo</a></li>
                    <li><a href="">Titulo del Blog numero 8, enlace directo</a></li>
                    <li><a href="">Titulo del Blog numero 9, enlace directo</a></li>
                    <li><a href="">Titulo del Blog numero 10, enlace directo</a></li>
                    <li><a href="">Titulo del Blog numero 11, enlace directo</a></li>
                </ul>
            </section>
            <section class="blog-section-description">
                <h1>Scope, Closures & Hoisting en JavaScript</h1>
                <p>Fecha de publicación: 6/07/21</p>

                <h3 id="index-scope">Scope</h3>
                <p><strong><u>¿Qué es Scope y cómo funciona?</u></strong></p>
                <p>El contexto actual de ejecución. El contexto en el que los valores y las expresiones son "visibles" o pueden ser referenciados.</p>
                
                <p>Si una variable u otra expresión no está "en el Scope- alcance actual", entonces no está disponible para su uso.</p> 

                <p>Los Scope también se pueden superponer en una jerarquía, de modo que los Scope secundarios tengan acceso a los ámbitos primarios, pero no al revés. </p>
                
                <p><u><strong>Global Scope:</strong></u> Las variables NO están dentro de funciones o bloques, por lo tanto se puede acceder a ellas de manera global.</p>

                <div class="code-background">
                    <code>
    
                    &nbsp var hello = "HELLO :)"; <br>
                    &nbsp var hello = "HELLO +:("; <br>
                    &nbsp let world = "Hello World"; <br>
                    &nbsp const helloWorld = "Hello World!!"; <br>

                    &nbsp const anotherFunction = () => {<br>
                        &nbsp &nbsp console.log(hello);<br>
                        &nbsp &nbsp console.log(world);<br>
                        &nbsp &nbsp console.log(helloWorld);<br>
                        &nbsp } <br>

                        &nbsp anotherFunction (); //Llamado de la función 
                    </code>
                </div>

                <p><strong><u> NOTA: </u></strong></p>
                <ul>
                    <li><p>Al correr el codigo, puede observarse que al definir 2 variables con el mismo nombre: se reescribe la segunda variable sobre la primera.</p></li>
                    <li><p>Por otra parte, <code>let</code> ni <code>const</code> no permite reeasignar un nuevo valor con el nombre asignado anteriormente.</p></li>
                    <li> <p>No es para nada buena practica definir variables de uso 
                    global dentro de bloques de codigo o dentro de funciones. Se hablará de esto en la sección de <a href="#index-hoisting">Hoisting</a></p></li>
                    <li><p>En el uso de variables la unica manera de reasignar variables es mediante el uso de var puesto que  let y const no lo permitirá.</p></li>
                </ul>

                <p><u><strong>Local Scope:</strong></u></p>
                <p>Las variables SI estan dentro de bloques de codigo o funciones, por lo cual se puede acceder a ellas SOLO en el bloque de codigo o la funcion.</p>
                <p>Pues fuera de la función o el bloque de codigo, esta variable no existirá.</p>

                <p><strong>Ejemplo 1</strong></p>
                <div class="code-background">
                    <code>
                        &nbsp const helloWorld = () => { <br>
                            &nbsp &nbsp const hello = 'hello World'; <br>
                            &nbsp &nbsp console.log(hello); <br>
                        &nbsp } <br>
                        &nbsp helloWorld(); <br>
                        &nbsp console.log(hello); 
                    </code>
                </div>
                <p><strong><u>NOTA:</u></strong> Al correr el codigo se observa que <code>console.log(hello);</code> No podra acceder a la const hello porque esta definida de manera local mas no de manera global.</p>

                <p><u><strong>Ejemplo 2</strong></u></p>
                <div class="code-background">
                    <code>
                        &nbsp var scope = "I'm just global" <br>
                        &nbsp const functionScope = () => { <br>
                            &nbsp &nbsp var scope = " I'm just local" <br>
                            &nbsp &nbsp const func = () => { <br>
                                &nbsp &nbsp &nbsp return scope; <br>
                            &nbsp &nbsp } <br>
                            &nbsp &nbsp console.log(func()); <br>
                        &nbsp } <br>
                        &nbsp functionScope (); //Retorna el scope local <br>
                        &nbsp console.log (scope); // Retorna el scope global
                    </code>
                </div>
                <p><strong><u>NOTA:</u></strong> Observese que al correr el codigo anterior al utilizar la función <code>functionScope ();</code> se logra acceder al scope local <code>scope = " I'm just local"</code> y al utilizar <code>console.log (scope);</code> solo se puede acceder a <code>scope = "I'm just global" </code>. </p>

                <p><u><strong>FUNCTION LOCAL SCOPE</strong></u></p>
                <p><strong>Ejemplo 1</strong></p>
                <div class="code-background">
                    <code>
                        &nbsp var scope = "I'm just global" <br>
                        &nbsp const functionScope = () => { <br>
                            &nbsp &nbsp var scope = " I'm just local" <br>
                            &nbsp &nbsp const func = () => { <br>
                                &nbsp &nbsp &nbsp return scope <br>
                            &nbsp } <br>
                            &nbsp &nbsp console.log(func()); <br>
                        &nbsp } <br>
                        &nbsp functionScope (); <br>
                        &nbsp console.log (scope); <br>
                    </code>
                </div>

                <p><strong>Ejemplo 2</strong></p>
                <div class="code-background">
                    <code>
                        &nbsp const fruits = () => { <br>
                        &nbsp var fruit = "apple"; <br>
                            &nbsp &nbsp console.log(fruit); <br>
                        &nbsp } <br>
                        &nbsp fruits (); <br>
                    </code>
                </div>

                <p><strong>Ejemplo 3</strong></p>
                <div class="code-background">
                    <code>
                        &nbsp const numberFunction = () => { <br>
                            &nbsp &nbsp var x = 1; <br>
                            &nbsp &nbsp var x = 2; <br>
                            &nbsp &nbsp var y = 1;<br>
                            &nbsp &nbsp var y = 2; <br>
                            &nbsp &nbsp console.log (x) <br>
                            &nbsp &nbsp console.log (y) <br>
                        &nbsp } <br>
                        &nbsp numberFunction (); 
                    </code>
                </div>
                <p><strong><u>NOTA:</u></strong> el primer valor asignado <code>x = 1</code> sera borrado y se reescribirá <code>x = 2</code> al igual que <code>y</code> por lo que al final se obtendran <code>x = 2</code> y también <code>y = 2</code>.</p>

                <p><strong><u>BLOCK LOCAL SCOPE</u></strong></p>
                <p><strong>Ejemplo 1</strong></p>

                <div class="code-background">
                    <code>
                        &nbsp const colors = () => { <br>
                            &nbsp &nbsp if (true) { <br>
                                &nbsp &nbsp &nbsp var color1 = "Blue"; <br>
                                &nbsp &nbsp &nbsp let color2 = "Yellow"; <br>
                                &nbsp &nbsp &nbsp const color3 = "Green"; <br>
                                &nbsp &nbsp &nbsp console.log(color2); <br>
                                &nbsp &nbsp &nbsp console.log(color3); <br>
                            &nbsp &nbsp } <br>
                            &nbsp &nbsp console.log(color1); <br>
                        &nbsp } <br>
                        &nbsp colors(); <br>
                    </code>
                </div>
                <p><strong><u>NOTA:</u></strong> </p>
                    <ul>
                        <li><p>Es importante resaltar que <code>console.log(color2)</code> y <code>console.log(color3)</code>  deben estar dentro del <strong>SCOPE DEL BLOQUE</strong> para ser llamados, de lo contratio lograra acceder a ellos.</p></li>
                        <li><p>Cabe mencionar tambien que <code>console.log(color1);</code> sí podra acceder porque var permite acceder dentro de la funcion local definida. Aunque no sea tan buena practica.</p></li>
                    </ul>
                
                <p><strong>Ejemplo 2</strong></p>
                <p><strong>CASO let</strong></p>
                <div class="code-background">
                    <code>
                        &nbsp let x = 1; <br>
                        &nbsp { <br>
                            &nbsp &nbsp let x = 2 <br>
                            &nbsp &nbsp console.log (x) // Retornará 2 <br>
                        &nbsp } <br>
                        &nbsp console.log(x); // Retornará 1 
                    </code>
                </div>

                <p><strong>CASO var</strong></p>
                <div class="code-background">
                    <code>
                        &nbsp var y = 1; <br>
                        &nbsp { <br>
                            &nbsp &nbsp var y = 2 <br>
                            &nbsp &nbsp console.log (x) // Retornará 2 <br>
                        &nbsp } <br>
                        &nbsp console.log(x); // Retornará 2 
                    </code>
                </div>

                <p><strong>Ejemplo 3</strong></p>  
                <div class="code-background">
                    <code>
                        &nbsp const anotherFunction = () => { <br>
                            &nbsp &nbsp for (let i = 0; i < 10; i++) { <br>
                                &nbsp &nbsp &nbsp setTimeout(() => { <br>
                                    &nbsp &nbsp &nbsp &nbsp console.log(i); <br>
                                    &nbsp &nbsp &nbsp }, 1000); <br>
                            &nbsp &nbsp }; <br>
                        &nbsp }; <br>
                        &nbsp anotherFunction();
                    </code>
                </div> 
                <p><strong><u>NOTA:</u></strong> Al poner <code>let</code> en lugar de <code>var</code> hace que por cada iteración muestre el valor del bloque ejecutado.
                Si se pusiera <code>var</code> reescribiría todas los resultados por el ultimo valor de <code>var</code>. 
                </p>
            
            <h3 id="index-closures">Closures</h3>
            <p>Según la definición estricta una clausura o closure es una función que guarda referencias del estado adyacente (ámbito léxico).</p>
            <p>En otras palabras, una clausura permite acceder al ámbito de una función exterior desde una función interior.</p>
            <p>En JavaScript, las clausuras se crean cada vez que una función es creada.</p>

            <p><strong>Ejemplo</strong></p>
            <div class="code-background">
                <code>
                    &nbsp const moneyBox = () => { <br>
                        &nbsp &nbsp var saveCoins = 0; <br>
                        &nbsp &nbsp const countCoins = (coins) => { <br>
                            &nbsp &nbsp &nbsp saveCoins += coins; <br>
                            &nbsp &nbsp &nbsp console.log(`MoneyBox: $$ {saveCoins}`); <br>
                        &nbsp &nbsp } <br>
                        &nbsp &nbsp return countCoins; <br>
                    &nbsp }; <br>
                    &nbsp let myMoneyBox = moneyBox(); <br>
                    &nbsp myMoneyBox(4); <br>
                    &nbsp myMoneyBox(6); <br>
                    &nbsp myMoneyBox(10); <br>
                </code>
            </div>


            <p><u><strong>Lexical</strong></u></p>

            <div class="code-background">
                <code>
                    &nbsp const buildCount = (i) => { <br>
                        &nbsp &nbsp let count = i; <br>
                        &nbsp &nbsp const displayCount = () => { <br>
                            &nbsp &nbsp &nbsp console.log(count++); <br>
                        &nbsp &nbsp }; <br>
                        &nbsp &nbsp return displayCount; <br>
                    &nbsp }; <br>
                
                    &nbsp const myCount = buildCount(3); <br>
                    &nbsp myCount(); <br>
                    &nbsp myCount(); <br>
                    &nbsp myCount(); <br>
                
                    &nbsp const myOtherCount = buildCount(10); <br>
                    &nbsp myOtherCount(); <br>
                    &nbsp myOtherCount(); <br>
                    &nbsp myOtherCount(); <br>
                </code>
            </div>
            <p><u><strong>NOTA:</strong></u> Cabe resaltar que la sintaxis <code>x++</code> realiza un incremento pero muestra el valor anterior al incremento, y la sintaxis <code>++x</code> realiza el incremento pero muestra el valor ya incrementado.</p>

            <p><u><strong>Private</strong></u></p>
            <div class="code-background">
                <code>
                    &nbsp const person = () => { <br>
                        &nbsp &nbsp var saveName = "Name"; <br>
                        &nbsp &nbsp return { <br>
                            &nbsp &nbsp &nbsp getName: () => { <br>
                                &nbsp &nbsp &nbsp &nbsp return saveName; <br>
                            &nbsp &nbsp &nbsp }, <br>
                            &nbsp &nbsp &nbsp setName: (name) => { <br>
                                &nbsp &nbsp &nbsp &nbsp saveName = name; <br>
                            &nbsp &nbsp &nbsp }, <br>
                        &nbsp &nbsp }; <br>
                        &nbsp }; <br>
                
                        &nbsp newPerson = person(); <br>
                        &nbsp console.log(newPerson.getName()); <br>    
                        &nbsp newPerson.setName('nombreCualquiera'); <br>
                        &nbsp console.log(newPerson.getName()); 
                </code>
            </div>

            <p><u><strong>Loops</strong></u></p>
            <div class="code-background">
                <code>
                    &nbsp const anotherFunction = () => { <br>
                        &nbsp &nbsp for (let i = 0; i < 10; i++){ <br>
                            &nbsp &nbsp &nbsp setTimeout(() => { <br>
                                &nbsp &nbsp &nbsp &nbsp console.log(i); <br>
                            &nbsp &nbsp &nbsp }, 1000) <br>
                        &nbsp &nbsp } <br>
                    &nbsp }; <br>
                    &nbsp anotherFunction();
                </code>
            </div>
            <p><strong><u>NOTA: </u></strong>El closure en este caso viene a ser el setTimeout() y como se mostró si se usa <code>var</code>, en el setTimeout() por consola se mostrará 10 veces 10 ya que el setTimeout es asíncrono y va ejecutarse luego de haber recorrido todo el for. Y tendrá el valor de 10 ya que var tiene un scope de función debido al hoisting (levantamiento).</p>



            <h3 id="index-hoisting">Hoisting</h3>
            <p>El concepto de Hoisting fue pensado como una manera general de referirse a cómo funcionan los contextos de ejecución en JavaScript (específicamente las fases de creación y ejecución).</p>
            <p>Conceptualmente, una estricta definición de hoisting sugiere que las declaraciones de variables y funciones son físicamente movidas al comienzo del código, pero esto no es lo que ocurre en realidad. </p>
            <p>Lo que sucede es que las declaraciones de variables var y funciones son asignadas en memoria durante la fase de compilación, pero quedan exactamente en dónde las has escrito en el código.</p>

            <p><strong>Ejemplo 1</strong></p>
            <p>Codigo ingresado</p>
            <div class="code-background">
                <code>
                    &nbsp a = 2; <br>
                    &nbsp var a;  <br>
                    &nbsp console.log(a) <br>
                </code>
            </div>

            <p>Interpretación de JavaScript</p>
            <div class="code-background">
                <code>
                    &nbsp var a;     //Declaración de la variable con valor undefined por defecto. <br>
                    &nbsp a = 2;     //Inicialización de la variable asignandole un valor <br>
                    &nbsp console.log(a); // Ejecución de llamado a la consola el valor a = 2
                </code>
            </div>

            <p><strong>Ejemplo 2</strong></p>
            <p>Codigo ingresado</p>
            <div class="code-background">
                <code>
                    &nbsp console.log(b); <br>
                    &nbsp var b = 3;  <br>
                    &nbsp console.log(b) <br>
                </code>
            </div>
            <p>Interpretación JavaScript</p>
            <div class="code-background">
                <code>
                    &nbsp var b;      // Declaración de la variable con valor undefined por defecto. <br>
                    &nbsp console.log(b) //Ejecución del llamado a la consola el valor de b = undefined. <br>
                    &nbsp var b = 3;  //Asignación de valor 3 a variable b<br>
                    &nbsp console.log(b) //Ejecución del llamado a la consola el valor de b = 3
                </code>
            </div>
    
    

            <p><strong>Ejemplo 3</strong></p>
            <p>Codigo ingresado</p>
            <div class="code-background">
                <code>
                    &nbsp nameOfDog('Elmo'); <br>
                    &nbsp function nameOfDog(name) {  <br>
                        &nbsp &nbsp console.log(name); <br>
                    &nbsp } 
                </code>
            </div>
            <p>Interpretación JavaScript</p>
            <div class="code-background">
                <code>
                    &nbsp function nameOfDog(name) { <br>
                        &nbsp &nbsp console.log(name); <br>
                    &nbsp }       // Guardado de la funcion en el scope actual <br>
                    &nbsp nameOfDog('Elmo'); //Asignación de un argumento a una función disponible en el scope
                </code>
            </div>
    
            </section>
        </section>
    </main>
    <footer class="index-footer">
        <ul class="index-footer-contact">
            <li><a href="https://www.linkedin.com/in/danielvaldivv/"><span><img src="/danielvaldivv/assets/icons/icons/linkedin.svg" alt="Logo LinkedIn"></span></a></li>
            <li><a href="https://github.com/danielvaldivv"><span><img src="/danielvaldivv/assets/icons/icons/github.svg" alt="Logo GitHub"></span></a></li>
            <li><a href="https://platzi.com/p/danielvaldivv/"><span><img src="/danielvaldivv/assets/icons/icons/platzi.svg" alt="Logo Platzi"></span></a></li>
            <li><a href="https://twitter.com/danielvaldivv/"><span><img src="/danielvaldivv/assets/icons/icons/twitter.svg" alt="Logo Twitter"></span></a></li>
        </ul> 
    </footer>
</body>
</html>

